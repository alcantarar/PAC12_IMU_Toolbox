function [data] = importIMUs(imu_folder, data, coordsys, school)
%IMPORTIMUS Imports IMeasureU IMU data and adds it to a MATLAB structure
%(data). Expects there to be 3 axes * 3 sensors (Accel, Gyro, Mag) in IMU
%data. This function was designed to be run after IMPORTFORCES, where the
%MATLAB structure is first generated (see {data} input).
%
%   INPUTS:
%   imu_folder:     String; folder containing baseline trial's IMU data
%                   files.
%   data:           MATLAB structure where IMU data is to be added.
%                   Typically generated by IMPORTFORCES function.
%   coordsys:       Optional argument to return IMU values in global
%                   coordinate system instead of local (device) coordinate
%                   system. Default is 'local'. 'global' has not been
%                   tested by Ryan and was carried over from CREATEDATASTRUCTURE
%                   function by Amy Silder (2018).
%
%   OUTPUTS:
%   data:           MATLAB Structure now containing IMU (accelerometer,
%                   magnetometer, gyroscope) data. Note: there are multiple
%                   time vectors; one for each sensor.
%

% Use local (device) coordinate system as default.
if ~exist('coordsys','var')
    coordsys = 'local';
end

IMU_files = dir([imu_folder '/*.csv']);
IMU_files = {IMU_files.name};
% for i = 1:size(IMU_file,2)
%     IMU_files{i} = IMU_file{i}(3:end) %remove initials hardcoded :(
% end
%see which IMU files are present
indx = false(3,3);
indx(1,:) = contains(IMU_files,{'Rshank','rshank','RightFibula','Right','R'},'IgnoreCase',0);
indx(2,:) = contains(IMU_files,{'Lshank','lshank','LeftFibula','Left','L'},'IgnoreCase',0);
indx(3,:) = contains(IMU_files,{'sacrum','Pelvis','pelvis','Sacrum', 'S'},'IgnoreCase',0);

% each row is a different sensor (Rshank, Lshank, Sacrum)
%Rshank is the 0 1 0 (2nd) file in IMU_files array
%Lshank is the 1 0 0 (1st) file in IMU_files array
%Sacrum is the 0 0 1 (3rd) file in IMU_files array

segment = {'Rshank','Lshank','Sacrum'};

for i = 1:3
    if sum(indx(i,:)) > 1
        error(['More than one csv file found for: ' segment{i} ' sensor. Aborting... check filename or search terms.'])
    end
end

try
    for s = 1:length(segment)
        disp(['Loading ' segment{s} ': ' IMU_files{indx(s,:)}])
        try
            raw.(segment{s}) = csvread([imu_folder '/' IMU_files{indx(s,:)}],1,0);  % test on PC
        catch
            if school == 'Oregon' %THIS IS A HOT FIX FOR OREGON IMU DATA
                warning(['Trying alternative import method for: ' segment{s}])
                try
                    fid=fopen(fullfile(imu_folder,IMU_files{indx(s,:)}),'r');
                    
                    df = textscan(fid,'%f,%f,%f,%f,%f,%f,%f,%f,%f,%f', 'HeaderLines',1); %furation and # of channels
                    
                    if any(abs(diff(cellfun(@numel, df)))) %see if number of elements in each column are different (indicating incomplete row).
                        min_len = min(cellfun(@numel, df));
                        tf = cellfun(@numel, df) == min_len;
                        for i = 1:length(df)
                            if tf(i) == 1 %too short, add NaN in there, will fix later
                                df{i} = [df{i};NaN];
                            else
                            end
                            df{i}(end) = NaN;
                        end
                    end
                    %ok took care of incomplete row, now need to keep reading document
                    
                    df2 = textscan(fid,'%f,%f,%f,%f,%f,%f,%f,%f,%f,%f', 'HeaderLines',2); %
                    %             if length(df{1}) + length(df2{1}) < 0.9*len
                    df3 = textscan(fid,'%f,%f,%f,%f,%f,%f,%f,%f,%f,%f', 'HeaderLines',0); %
                    %             end
                    
                    fclose(fid);
                    
                    for i = 1:10
                        newdata{i} = [df{i};df2{i};df3{i}];
                        newdata{i} = fillmissing(newdata{i}, 'linear');
                    end
                    
                    raw.(segment{s}) = cell2mat(newdata);
                    data.IMU.(segment{s}).a = raw.(segment{s})(:,2:4);
                    data.IMU.(segment{s}).w = raw.(segment{s})(:,5:7);
                    data.IMU.(segment{s}).m = raw.(segment{s})(:,8:10);
                    data.IMU.(segment{s}).time = raw.(segment{s})(:,1);
                catch
                    warning(['Alternative import method failed for: ' segment{s}])
                end
            else
                warning(['could not find IMU file for the following segment: ' segment{s}])
            end
        end
        data.IMU.(segment{s}).a = raw.(segment{s})(:,2:4);
        data.IMU.(segment{s}).w = raw.(segment{s})(:,5:7);
        data.IMU.(segment{s}).m = raw.(segment{s})(:,8:10);
        data.IMU.(segment{s}).time = raw.(segment{s})(:,1);
    end
catch
    warning(['could not find IMU file for the following segment: ' segment{s}])
end
    
    %% NOT TESTED! FROM ORIGINAL AMY SILDER CODE. Only runs on coordsys = 'global'
    % Optional: convert local coordinate systems to global based on gravity
    % during quiet standing
    
    if strcmpi(coordsys,'global')
        warning("IMU data in Global Coordinate System has not been tested. Recommend using 'local' coordsys parameter instead.")
        % Determine the orientation of the sensor on the person and convert to world reference frame
        % Right ankle
        % Use angular acceleration to find the left-pointing Y-vector
        w=data.IMU.Rshank.w;
        PCAcoeff=pca(w);
        Y = (PCAcoeff(:,1))';
        Y = Y./norm(Y);
        
        % Use gravity to define up-pointing Z-vector
        a=data.IMU.Rshank.a;
        plot(a); title('Choose two points during quiet standing'); pause; [x,~]=ginput(2); close;
        x=round(x);
        Z = mean(a(x(1):x(2),:));
        Z = Z./norm(Z);
        
        % Y x Z = forward-pointing X vector
        X = cross(Y,Z);
        X = X./norm(X);
        
        % Re-calculate X to ensure orthogonality
        Y = cross(Z,X);
        Y = Y./norm(Y);
        
        % Define direction cosine matrix of the sensor in the world
        IMU2World_RShank = [X; Y; Z];
        
        % Convert IMU data into the world's coordinate reference frame
        % z-up, x-forward, y-left
        aright=a*IMU2World_RShank';
        wright=w*IMU2World_RShank';
        % Subtract gravity
        aright(:,3)=aright(:,3)-9.81;
        
        data.IMU.Rshank.a = aright;
        data.IMU.Rshank.w = wright;
        
        % Left ankle
        % Use angular acceleration to find the left-pointing Y-vector
        w=data.IMU.Lshank.w;
        PCAcoeff=pca(w);
        Y = (PCAcoeff(:,1))';
        Y = Y./norm(Y);
        
        % Use gravity to define up-pointing Z-vector
        a=data.IMU.Lshank.a;
        Z = mean(a(x(1):x(2),:));
        Z = Z./norm(Z);
        
        % Y x Z = forward-pointing X vector
        X = cross(Y,Z);
        X = X./norm(X);
        
        % Re-calculate X to ensure orthogonality
        Y = cross(Z,X);
        Y = Y./norm(Y);
        
        % Define direction cosine matrix of the sensor in the world
        IMU2World_LShank = [X; Y; Z];
        
        % Convert IMU data into the world's coordinate reference frame
        % z-up, x-forward, y-left
        aleft=a*IMU2World_LShank';
        wleft=w*IMU2World_LShank';
        % Subtract gravity
        aleft(:,3)=aleft(:,3)-9.81;
        
        data.IMU.Lshank.a = aleft;
        data.IMU.Lshank.w = wleft;
        
        % Sacrum
        % Use angular acceleration to find the left-pointing Y-vector
        w=data.IMU.sacrum.w;
        PCAcoeff=pca(w);
        Y = (PCAcoeff(:,1))';
        Y = Y./norm(Y);
        
        % Use gravity to define up-pointing Z-vector
        a=data.IMU.sacrum.a;
        Z = mean(a(x(1):x(2),:));
        Z = Z./norm(Z);
        
        % Y x Z = forward-pointing X vector
        X = cross(Y,Z);
        X = X./norm(X);
        
        % Re-calculate X to ensure orthogonality
        Y = cross(Z,X);
        Y = Y./norm(Y);
        
        % Define direction cosine matrix of the sensor in the world
        IMU2World_sacrum = [X; Y; Z];
        
        % Convert IMU data into the world's coordinate reference frame
        % z-up, x-forward, y-left
        asacrum=a*IMU2World_sacrum';
        wsacrum=w*IMU2World_sacrum';
        % Subtract gravity
        asacrum(:,3)=asacrum(:,3)-9.81;
        
        data.IMU.sacrum.a = asacrum;
        data.IMU.sacrum.w = wsacrum;
    else
    end
    
end

